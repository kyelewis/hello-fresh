# Hello, Fresh

This is my attempt to create a template scaffold for fresh that works the way i
would like.

The fresh docs don't document this, they provide this command to create a
scaffold app:

```sh
deno run -A -r https://fresh.deno.dev my-app
```

This script redirects to the fresh `init.ts` script
(https://github.com/denoland/fresh/blob/main/init.ts), which:

- Checks if the directory provided as an argument is empty
- Asks if you want to use twind, a styling library, and sets it up if sp
- Creates the folder structure
- Fills out a number of template files

Let's do it all ourselves instead:

## 1. Create the basic directory structure

The official fresh `init` script doesn't use a src/ folder for holding the
source code- but I much prefer this to help visually and logically seperate out
source code from docs, metadata and dotfiles. It works fine with fresh.

There are hardcoded folders that fresh looks for things in:

- `public`, for holding static assets
- `islands`, for creating client-side interactive components (everything else in
  fresh is server-side rendered)
- `routes`, for the routes to serve

Only `routes` is required to get started, so we'll just create that one- explore
the others as you go.

```sh
mkdir -p src/routes
```

## 2. Create a deno.json (optional!)

`fresh` defines a task (`start`) and an import map in a `deno.json` config file.

This is technically optional, and you can just run
`deno run src/dev.ts --import-map ./import_map.json`, however I do think that it
is useful to have these documented and kept somewhere standard.

By default, fresh uses the `-A` flag from deno, which means "allow all
permissions". This completely ignores the entire deno security model, and I hate
it. However, having tried to actually specify the things it should be allowed
access to, this is hard!

I defined a set of sensible allow flags to get started, but it is not entirely
complete yet.

You'll need to give permission for:

#### --allow-net

- 0.0.0.0:8080 (or another port, if you choose) for the server to run on.

- Each domain that source pulls down from, at a minimum:
  - deno.land (fresh@1.0.0)
  - esm.sh (preact)
  - crux.land (?)
  - unpkg.com (?)

#### --allow-env

- FRSH_DEV_PREVIOUS_MANIFEST
- DENO_DEPLOYMENT_ID

#### --allow-read

- ./

#### --allow-write

- ./src/fresh.gen.ts

References: https://deno.land/manual/getting_started/configuration_file
https://deno.land/manual/tools/task_runner

```json
{
  "tasks": {
    "start": "deno run --allow-env=FRSH_DEV_PREVIOUS_MANIFEST,DENO_DEPLOYMENT_ID --allow-read='./' --allow-write='./src/fresh.gen.ts' --allow-net='0.0.0.0:8080,deno.land,esm.sh,crux.land,unpkg.com' --watch=routes/ src/dev.ts"
  },
  "importMap": "./import_map.json"
}
```

## 3. Create the import map.

Remember that deno doesn't have a node_modules to resolve from.

Historically in deno, packages have either directly included URLs in the source,
or used a `deps.ts` file to put all dependencies in the one place for use.

Fresh's template uses the import maps feature in deno to resolve imports, for
example, turn something like `import { r } from "preact"` into
`import { r } from  "https://esm.sh/preact@10.8.1"`.

You'll notice multiple imports here: "preact" matches `from "preact"` but not
`from "preact/..."`, so we need two for these cases.

I'm not sure if you can just use a `deps.ts` instead of the import map.

References: https://deno.land/manual/linking_to_external_code/import_maps WICG
import maps proposal: https://github.com/WICG/import-maps importmap.json

```import_map.json
{
  "imports": {
    "fresh/": "https://deno.land/x/fresh@1.0.0",
    "preact": "https://esm.sh/preact@10.8.1",
    "preact/" "https://esm.sh/preact@10.8.1",
    "preact-render-to-string": "https://esm.sh/preact-render-to-string@5.2.0?deps=preact@10.8.1",
  }
}
```

## 4. Create the main.ts and dev.ts files

### main.ts

`main.ts` is the main server entry point, and is fairly straightforward. It is
passed in a manifest file, that is generated by the dev method when it is run.

The second argument to start is an options object to set, for example, the port
or hostname of the server. You can also pass it a render function that can wrap
the inner render function with access to the context.

```ts
import { start } from 'fresh/server.ts"';
import manifest from "./fresh.gen.ts";
await start(manifest, { port: 8080 });
```

### dev.ts

`dev.ts` is a wrapper that generates a new manifest file, if the routes,
islands, etc... have changed:

```ts
import dev from "fresh/dev.ts";
await dev("./main.ts");
```

## 5. Create a hello, world default route

We have to define the pragma manually so that we know which render function to
use for the JSX.

Make sure to use the `tsx` extension (if you use JSX) or you'll see parse errors
when you run the project.

routes/index.tsx:

```typescript
/** @jsx h */
import { h } from "preact";

export default function Home() {
  return (
    <div>
      <h2>Hello, Fresh!</h2>
    </div>
  );
}
```

## Run it

```sh
deno task start
```
